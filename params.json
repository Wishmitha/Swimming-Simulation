{"name":"Swimming-simulation","tagline":"A Swimming Simulation developed using Java. Basic concepts on Object oriented programing, Java threads, GUI design and MVC architecture was used in development process.","body":"Name : W.S Mendis\r\n\r\n\r\n**CS2012 : Principles of Object Oriented Programming – Semester Project – Final Report**\r\n\r\n**Uses of fundamental OOP Principles :**\r\n\r\n**1. Inheritance :**\r\nInheritance allows the subclasses inherit all the attributes and methods of their superclass. As clearly\r\ndisplayed in the UML diagram, inheritance was used in several occasions in this project. All the\r\nhuman related classes such as Swimmer, Judge, Spectator, \\Inheritance allows the subclasses inherit\r\nall the attributes and methods of their superclass. As clearly displayed in the UML diagram,\r\ninheritance was used in several occasions in this project. All the human related classes such as\r\nSwimmer, Judge, Spectator, SupportStaff etc. inherits from Person super class. And MaleSwimmer\r\nand FemaleSwimmer classes inherits from abstract Swimmer class. So, this concept is useful in code\r\nredundancy and extending the reusability.\r\n\r\n**2. Abstraction :**\r\nAbstraction concept is referred to ignoring irrelevant aspects and focusing of reflecting aspects of an\r\nobject. This concept is useful in handling the complexity of the project. Couple of abstract classes\r\nsuch as Person and Swimmer were used in this project. Even though these classes cannot be\r\ninstantiated, they minimizes the complexity by holding attributes and methods of their subclasses.\r\nThe abstract methods such as doBackStroke(), doBreastStroke() etc in Swimmer class are useful in\r\nimplementing (overriding) each method slightly differently in MaleSwimmer and FemaleSwimmer\r\nclasses. (Line – 115,116,117,118 in Swimmer Class)\r\n\r\n**3. Polymorphism :**\r\nThe ability of an object to take many forms is called as polymorphism. Polymorphism was mainly\r\nused Swimmer type ArrayLists (ArrayList<Swimmer>) which can store objects of both\r\nMaleSwimmer and FemaleSwimmer types. (Line – 13,14 in PeopleTrack Class) This reduces the\r\ncomplexity of the project by giving a more generic type to store different types of objects. The sameconcept was used in method load in SaveLoadData class where a ArrayList of type Person\r\n(ArrayList<Person>) was declared to store different types of objects (Swimmers, Judges etc.)\r\n(Line – 26 in SaveLoadData Class) In ThreadMovement class the ArrayList results of type\r\nSwimmer is used to store both male and female swimmers. (Line - 28 in ThreadMovement Class)\r\n\r\n**4. Encapsulation :**\r\nEncapsulation is referred to hiding of implemented attribute in order to maintain the security of the\r\ncode. This concept was used in this project to hide the most important attributes such as ArrayLists\r\nwhich keeps track on people in PeopleTrack class. (Line – 13,14,15,16 in PeopleTrack Class) These\r\nArrayLists were declared private, therefore they cannot be accessed or edited from a outside class.\r\nThese lists were maintained by using setter and getter methods. Other than this, in almost all the\r\nclasses, the encapsulation is maintained by declaring attributes private and implementing setters and\r\ngetters.\r\n\r\n**Concurrency Control**\r\n\r\nThe movement of the each swimmer is configured by a thread which is implemented in\r\nThreadMovement Class. This class is a subclass of Thread class in Java, therefore the run() method\r\nwas overridden to initiate the movement of each swimmer. In the run() method, the movement of the\r\nswimmer is configured by generating a random value according to the swimmer's rating (which is\r\ngiven by the user) and summing them inside a loop. (Line – 74,76,83 in ThreadMovement Class)\r\nThis will make sure that the movement of each swimmer differ from one another. These threads are\r\ninitiated ( Thread.start() ) in the doBackStroke(), doBreastStroke() etc methods in the MaleSwimmer\r\nand FemaleSwimmer classes.\r\nSo, whenever a new simulation begins multiple threads will start and creates a multi threaded\r\nenvironment. However all the threads in this projects are mainly used configure the movement of the\r\nswimmer, therefore even there are interruptions between the threads, it doesn't really break the\r\nprogress of the simulation. And the sleep time of the thread was minimized to around 40 milliseconds to maintain a smooth flow in GUI movement, otherwise sliders tend to show a lagging movement. (Line – 79 in ThreadMovement Class)\r\nOther than setting the movement of swimmers, these threads in ThreadMovement Class updates the\r\nstatus of the Judges and Spectators, displays and records the results, and updates the GUI in differentstages of their running time. (Line – 68,69,70 in ThreadMovent Class) Because run method is\r\ndeclared as a synchronized method multiple threads cannot perform above functions simultaneously.\r\nThis useful in maintaining the flow and continuity of the GUI.\r\n\r\n**Observer Observable Concept**\r\n\r\nObserver Observable concept was used in this project to build the relation between Spectator and the\r\nScore Board. In this project this relation was built manually without using in built the Observer and\r\nObservable classes in Java.\r\nIn this scenario Observer is the Spectator and the Observable is the Score Board which notifies the\r\nObserver when states changed. First a ArrayList of type Spectator (ArrayList<Spectator>) was\r\nimplemented inside the Class ScoreBoard. This is one of the fundamentals of this concept where\r\nObservable should consist of a list of Observers. Usually there should be attach() and detach()\r\nmethods inside the Observable Class in order to maintain list of Observers, but in this case these\r\nmethods haven't been implemented because PeopleTrack Class already keeps track on every Spectator\r\ncreated in the simulation. (Line – 16 in PeopleTrack class) Therefore that list of Spectators is\r\nimplemented inside the ScoreBoard class.\r\nThen the notifySpectator(int i) method was implemented to update all the Spectators in the list (Line\r\n– 45 in ScoreBoard Class) This integer parameter (i) is given by the running thread, and inside the\r\nmethod this value is passed to the update(int i) method in Spectator Class. According to this value\r\nSpectator changes its status (Line – 33 in Spectator Class) In order to Spectator objects to be updated\r\naccording the ScoreBoard states, notifySpectator(int i) method should constantly feed update(int i)\r\nmethod with values given by the Thread. It is done in the ThreadMovement Class. (Line – 71,90 in\r\nThreadMovement Class)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}